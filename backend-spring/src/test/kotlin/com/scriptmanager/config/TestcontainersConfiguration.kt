package com.scriptmanager.config

import org.springframework.boot.test.context.TestConfiguration
import org.springframework.boot.testcontainers.service.connection.ServiceConnection
import org.springframework.context.annotation.Bean
import org.testcontainers.containers.PostgreSQLContainer
import org.testcontainers.utility.DockerImageName
import java.time.Duration

/**
 * Testcontainers configuration for integration tests.
 *
 * This spins up a real PostgreSQL database in Docker for testing,
 * avoiding the limitations of in-memory databases.
 *
 * Benefits over in-memory databases:
 * 1. Tests against the actual production database engine
 * 2. Can test database-specific features (triggers, functions, etc.)
 * 3. More realistic performance characteristics
 * 4. Can inspect the database after tests if needed
 *
 * The @ServiceConnection annotation automatically configures Spring Boot
 * to use this container's connection details.
 */
@TestConfiguration(proxyBeanMethods = false)
class TestcontainersConfiguration {

    /**
     * PostgreSQL container that will be shared across all tests.
     * Using singleton pattern to avoid spinning up multiple containers.
     *
     * Applies Prisma schema from src-tauri/prisma/schema.prisma if available.
     */
    @Bean
    @ServiceConnection
    fun postgresContainer(): PostgreSQLContainer<*> {
        val container = PostgreSQLContainer(DockerImageName.parse("postgres:15-alpine"))
            .withDatabaseName("testdb")
            .withUsername("test")
            .withPassword("test")
            .withStartupTimeout(Duration.ofMinutes(2))
            .withReuse(true) // Reuse container across test runs for faster execution

        container.start()
        printConnectionInfo(container)

        println()
        println("â„¹ï¸  Schema will be auto-generated by Hibernate from JPA @Entity classes")
        println("   (spring.jpa.hibernate.ddl-auto=create-drop in application-test.yml)")
        println()

        return container
    }


    /**
     * Prints connection information for connecting with GUI tools (DataGrip, DBeaver, etc.)
     */
    private fun printConnectionInfo(container: PostgreSQLContainer<*>) {
        val host = container.host
        val port = container.getMappedPort(5432)
        val database = container.databaseName
        val username = container.username
        val password = container.password
        val jdbcUrl = container.jdbcUrl

        println("=".repeat(80))
        println("ğŸ”— TESTCONTAINERS DATABASE CONNECTION INFO")
        println("=".repeat(80))
        println("ğŸ“ Host:     $host")
        println("ğŸ”Œ Port:     $port")
        println("ğŸ’¾ Database: $database")
        println("ğŸ‘¤ Username: $username")
        println("ğŸ”‘ Password: $password")
        println("ğŸ”— JDBC URL: $jdbcUrl")
        println()
        println("ğŸ“Š GUI Tool Connection (DataGrip, DBeaver, TablePlus, etc.):")
        println("   Host: $host")
        println("   Port: $port")
        println("   Database: $database")
        println("   User: $username")
        println("   Password: $password")
        println()
        println("ğŸ˜ psql command:")
        println("   docker exec -it \$(docker ps | grep postgres | awk '{print \$1}') psql -U $username -d $database")
        println()
        println("ğŸ’¡ Container will stay alive with reuse=true")
        println("   To find it: docker ps | grep postgres")
        println("=".repeat(80))
    }
}

